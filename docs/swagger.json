{
    "schemes": [
        "http",
        "https"
    ],
    "swagger": "2.0",
    "info": {
        "description": "A high-performance content storage server with enterprise features including expiration, access limits, backup management, and sequential write processing.\n\n## Configuration Impact on API Behavior\n\nThe server behavior is heavily influenced by environment configuration:\n\n### Authentication (ENABLE_AUTH)\n- When `ENABLE_AUTH=true`: All API endpoints except `/health`, `/health/detailed`, `/ping`, and `/debug/*` require authentication\n- Authentication methods: `X-API-Key` header or `api_key` query parameter\n- When `ENABLE_AUTH=false`: All endpoints are publicly accessible\n\n### Content Size Limits (MAX_CONTENT_SIZE)\n- Default: 10MB (10485760 bytes)\n- All content storage operations validate against this limit\n- Exceeding this limit returns HTTP 400 with validation error\n\n### Rate Limiting (THROTTLE_LIMIT, THROTTLE_BACKLOG_LIMIT)\n- `THROTTLE_LIMIT`: Maximum concurrent requests (default: 1000)\n- `THROTTLE_BACKLOG_LIMIT`: Maximum queued requests (default: 50)\n- Exceeding limits returns HTTP 429 Too Many Requests\n\n### Content Type Restrictions (ALLOWED_CONTENT_TYPES)\n- Default: `application/json,text/plain`\n- Only specified content types are accepted for requests\n- Invalid content types return HTTP 415 Unsupported Media Type\n\n### Compression (ENABLE_COMPRESSION, COMPRESSION_LEVEL)\n- When enabled, responses are compressed based on Accept-Encoding header\n- Compression level affects CPU usage vs bandwidth trade-off\n\n### Backup \u0026 Storage Reliability\n- `BACKUP_INTERVAL`: Automated backup frequency (default: 6h)\n- `GC_INTERVAL`: Garbage collection frequency (default: 5m)\n- `PERFORMANCE_MODE`: Enable performance optimizations (default: true)\n- Sequential write processing ensures data consistency and emergency shutdown capabilities\n\n### Emergency Shutdown \u0026 Recovery\n- `ENABLE_EMERGENCY_RECOVERY`: Enable automatic recovery from emergency shutdowns (default: true)\n- Emergency shutdown preserves volatile queue state for automatic recovery on restart\n- Graceful shutdown (SIGTERM, single Ctrl+C): Waits for pending operations with 30s timeout\n- Emergency shutdown (SIGUSR1, double Ctrl+C): Immediate termination with state preservation\n- Recovery files stored in `backups/emergency-recovery/` with automatic archival after processing\n\n### Write Queue System\n- `WRITE_QUEUE_SIZE`: Maximum queue capacity (default: 1000, auto-doubles when full)\n- `WRITE_QUEUE_BATCH_SIZE`: Items processed per batch (default: 10)\n- `WRITE_QUEUE_BATCH_TIMEOUT`: Maximum wait before processing partial batch (default: 100ms)\n- Sequential processing prevents race conditions and ensures data consistency\n- Queue metrics available via `/api/v1/metrics` endpoint for monitoring\n",
        "title": "Content Storage Server API",
        "termsOfService": "https://example.com/terms/",
        "contact": {
            "name": "API Support",
            "url": "https://example.com/support",
            "email": "support@example.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "1.0"
    },
    "host": "localhost:8081",
    "basePath": "/",
    "paths": {
        "/api/v1/backup": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Create a manual backup of the database with optional configuration, comprehensive logging, and detailed response information\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **BACKUP_DIR**: Determines where backups are stored (from server configuration)\n- **Storage backend dependent** - Only supported for BadgerDB storage\n\n## Request Parameters:\n- **backup_name**: Optional custom backup name (defaults to timestamp-based naming)\n- **immediate**: Optional flag to force immediate backup (defaults to true)\n- Invalid JSON in request body defaults to immediate backup with auto-generated name\n\n## Backup Process:\n- Creates immediate backup regardless of BACKUP_INTERVAL schedule\n- Backup includes all current data, metadata, and access tracking information\n- Returns detailed backup information including path, size, and creation time\n- Operation duration varies with database size (logged for monitoring)\n- Comprehensive request logging with client IP, request ID, and user agent\n\n## Response Information:\n- Backup path and file size from storage backend\n- Creation timestamp and operation duration\n- Backup statistics for monitoring and verification",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Management Operations"
                ],
                "summary": "Create manual database backup with comprehensive monitoring",
                "parameters": [
                    {
                        "description": "Backup configuration (optional)",
                        "name": "backup",
                        "in": "body",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerBackupRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Backup created successfully",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerBackupResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Backup operation failed",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "501": {
                        "description": "Backup not supported for storage type",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/cleanup": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Manually trigger cleanup of stale access trackers to prevent memory leaks\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **Storage backend dependent** - Only supported for BadgerDB storage\n\n## Behavior:\n- Removes stale access tracking data for non-existent content\n- Prevents memory leaks from accumulating access counters\n- Returns count of removed trackers and operation duration\n- Safe to run during normal operations",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Management Operations"
                ],
                "summary": "Cleanup access trackers",
                "responses": {
                    "200": {
                        "description": "Cleanup completed successfully",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerCleanupResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/content": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "List all content with support for pagination, advanced filtering, and real-time access count information\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **ENABLE_COMPRESSION**: Response may be compressed based on Accept-Encoding\n\n## Pagination:\n- Default limit: 100, maximum: 1000 (hardcoded limit for performance)\n- Use offset for pagination through large result sets\n- Returns total count for pagination metadata\n\n## Advanced Filtering:\n- **type**: Filter by MIME type (e.g., \"application/json\", \"text/plain\")\n- **tag**: Filter by content tag/classifier\n- **created_after**: Filter content created after timestamp (RFC3339 format)\n- **created_before**: Filter content created before timestamp (RFC3339 format)\n- **include_expired**: Include expired content in results (default: false)\n\n## Access Count Integration:\n- Each content item includes real-time access_count from separate tracking system\n- Access counts are retrieved efficiently for all returned items\n- Expiration status is calculated using current access counts\n\n## Filtering Options:\n- **type**: Filter by content type (e.g., \"text/plain\")\n- **tag**: Filter by content tag\n- **created_after**: Filter content created after timestamp (RFC3339)\n- **created_before**: Filter content created before timestamp (RFC3339)\n- **include_expired**: Include expired content (default: false)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Content Operations"
                ],
                "summary": "List content with advanced filtering and access count tracking",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 100,
                        "example": 50,
                        "description": "Number of items per page (max: 1000)",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 0,
                        "example": 0,
                        "description": "Number of items to skip",
                        "name": "offset",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "\"text/plain\"",
                        "description": "Filter by content type",
                        "name": "type",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "\"user-documents\"",
                        "description": "Filter by content tag",
                        "name": "tag",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "\"2024-01-01T00:00:00Z\"",
                        "description": "Filter content created after (RFC3339)",
                        "name": "created_after",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "\"2024-12-31T23:59:59Z\"",
                        "description": "Filter content created before (RFC3339)",
                        "name": "created_before",
                        "in": "query"
                    },
                    {
                        "type": "boolean",
                        "default": false,
                        "example": false,
                        "description": "Include expired content",
                        "name": "include_expired",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Content listed successfully",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerContentListResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid pagination or filter parameters",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Store new content in the system using sequential write queue for data consistency and emergency shutdown capabilities\n\n## Configuration Dependencies:\n- **MAX_CONTENT_SIZE**: Validates content size (default: 10MB)\n- **ALLOWED_CONTENT_TYPES**: Validates request content type (default: application/json,text/plain)\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **PERFORMANCE_MODE**: Enables optimized validation when true (default: true)\n\n## Sequential Write Processing:\n- Content is queued for sequential processing to ensure data consistency\n- Returns HTTP 202 (Accepted) immediately after validation and queuing\n- Use GET /api/v1/content/{id}/status to check storage completion\n- Emergency shutdown capabilities preserve queued content\n\n## Validation Rules:\n- ID: Required, max 255 chars, alphanumeric with dots/hyphens/underscores, no dangerous path patterns\n- Data: Required, non-empty, size limited by MAX_CONTENT_SIZE\n- Type: Required, must match ALLOWED_CONTENT_TYPES, follows MIME type format\n- Tag: Optional, max 100 chars, alphanumeric with dots/hyphens/underscores\n- AccessLimit: Optional, 0-1,000,000, content expires after this many retrievals\n- ExpiresAt: Optional, RFC3339 format, cannot be in the past, max 10 years in future",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Content Operations"
                ],
                "summary": "Store new content with sequential write processing",
                "parameters": [
                    {
                        "description": "Content to store",
                        "name": "content",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerStorageRequest"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Content queued for storage",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerSuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Validation failed or invalid request",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "413": {
                        "description": "Content size exceeds MAX_CONTENT_SIZE limit",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "415": {
                        "description": "Content type not in ALLOWED_CONTENT_TYPES",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/content/count": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Get the total number of stored content items in the system using optimized storage-level counting\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **ENABLE_COMPRESSION**: Response may be compressed based on Accept-Encoding\n\n## Performance Characteristics:\n- Fast operation using storage-level counting (no iteration required)\n- Returns total count of all content items (including expired and access-limited)\n- Does not include queued items that haven't been persisted yet\n- Consistent with database state, not affected by write queue contents",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Content Operations"
                ],
                "summary": "Get total content count with storage-level optimization",
                "responses": {
                    "200": {
                        "description": "Content count retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerCountResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/content/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Retrieve specific content by ID with atomic access count increment and expiration checking\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **ENABLE_COMPRESSION**: Response may be compressed based on Accept-Encoding\n\n## Atomic Access Tracking:\n- Access count increment and expiration check are handled atomically in storage layer\n- Prevents race conditions between access counting and expiration validation\n- Access count is tracked separately from content data for performance\n\n## Expiration Behavior:\n- Returns 404 if content not found or time-expired\n- Returns 410 if content has reached its access limit (access_count \u003e access_limit)\n- Time-based expiration: content expires after ExpiresAt timestamp\n- Access-based expiration: content expires when access count exceeds AccessLimit\n\n## ID Validation:\n- Must be alphanumeric with dots, hyphens, underscores only\n- No dangerous path patterns (no \"..\", leading/trailing dots)\n- Maximum 255 characters, valid UTF-8",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Content Operations"
                ],
                "summary": "Retrieve content by ID with atomic access tracking",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"user-123-document\"",
                        "description": "Content ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Content retrieved successfully",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/internal_handlers.SwaggerSuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/internal_handlers.SwaggerContent"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid content ID format",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Content not found or expired",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "410": {
                        "description": "Content access limit reached",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Delete specific content by ID from the storage system with intelligent retry logic for write conflicts\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **ENABLE_WARN_LOGGING**: Controls retry attempt logging verbosity\n\n## Write Conflict Handling:\n- Automatically retries deletion if content is currently being written to queue\n- Uses WaitForContentWrite to wait for ongoing write operations to complete\n- Maximum 3 retry attempts with 100ms delay between attempts\n- 5-second timeout per write completion wait\n\n## Behavior:\n- Permanently removes content from storage and cleans up access tracking\n- Returns 404 if content not found\n- Validates ID format before deletion (same rules as GET/POST)\n- Handles race conditions with concurrent write operations gracefully",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Content Operations"
                ],
                "summary": "Delete content by ID with write conflict handling",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"user-123-document\"",
                        "description": "Content ID to delete",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Content deleted successfully",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerSuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid content ID format",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Content not found",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/content/{id}/status": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Check the current storage status of content with visibility into sequential write queue processing\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **Storage backend dependent**: Queue checking only available for BadgerDB storage\n\n## Status Values and Processing Flow:\n- **queued**: Content is in write queue awaiting sequential processing (HTTP 200)\n- **stored**: Content is persisted to disk and available for retrieval (HTTP 200)\n- **not_found**: Content ID does not exist in system or queue (HTTP 404)\n\n## Use Cases:\n- Monitor async content storage completion after POST /api/v1/content\n- Verify content availability before attempting retrieval\n- Debug storage pipeline issues and queue processing delays\n- Implement polling-based confirmation of content persistence",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Content Operations"
                ],
                "summary": "Get content storage status with queue visibility",
                "parameters": [
                    {
                        "type": "string",
                        "example": "\"user-123-document\"",
                        "description": "Content ID to check status",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Content status retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerContentStatusResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid content ID format",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Content not found",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/gc": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Manually trigger database garbage collection to reclaim disk space and optimize performance\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **Storage backend dependent** - Only supported for BadgerDB storage\n\n## Behavior:\n- Forces immediate garbage collection on the database\n- Reclaims disk space from deleted or expired content\n- May temporarily impact performance during operation\n- Operation duration varies based on database size",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Management Operations"
                ],
                "summary": "Trigger manual garbage collection",
                "responses": {
                    "200": {
                        "description": "Garbage collection completed successfully",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerGCResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Garbage collection failed",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/metrics": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Retrieve detailed system metrics including storage health, performance statistics, and operational intelligence for monitoring and alerting\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **Storage backend dependent** - Metrics vary based on storage implementation\n- **Backup configuration** - Backup stats depend on BACKUP_INTERVAL and backup settings\n\n## BadgerDB Metrics Categories:\n- **Content Statistics**: Total count, database size, growth trends\n- **Storage Health**: Database health status, corruption detection, disk usage\n- **Backup System**: Last backup time, backup count, backup success rate, backup sizes\n- **Garbage Collection**: Run frequency, duration statistics, space reclaimed, efficiency\n- **Access Management**: Active tracker count, cleanup statistics, memory usage\n- **System Health**: Overall health status (healthy/degraded/unhealthy)\n\n## Health Status Determination:\n- **healthy**: All systems operating within normal parameters\n- **degraded**: Some systems showing performance issues but functional\n- **unhealthy**: Critical systems failing or corrupted\n\n## Use Cases:\n- Monitoring dashboards and alerting systems\n- Performance analysis and capacity planning\n- Troubleshooting storage and performance issues\n- Automated health checks and SLA monitoring",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health \u0026 Monitoring"
                ],
                "summary": "Get comprehensive system metrics with operational intelligence",
                "responses": {
                    "200": {
                        "description": "Metrics retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerMetricsResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/sync": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "ApiKeyQuery": []
                    }
                ],
                "description": "Manually trigger a database synchronization operation with comprehensive logging and monitoring\n\n## Configuration Dependencies:\n- **ENABLE_AUTH**: Requires authentication when enabled\n- **THROTTLE_LIMIT**: May return 429 if rate limit exceeded\n- **Storage backend dependent** - Sync behavior varies by storage implementation\n\n## Current Implementation:\n- **Stub implementation**: No actual synchronization logic is performed\n- Comprehensive request logging with client IP, request ID, and user agent\n- Duration tracking for monitoring and performance analysis\n- Always returns success for compatibility with monitoring systems\n\n## Future Enhancement:\n- Intended for database synchronization operations\n- May improve performance after heavy write operations\n- Could include write queue flushing and database consistency checks",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Management Operations"
                ],
                "summary": "Trigger manual database synchronization (stub implementation)",
                "responses": {
                    "200": {
                        "description": "Sync completed successfully",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerSuccessResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required (when ENABLE_AUTH=true)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "429": {
                        "description": "Rate limit exceeded (THROTTLE_LIMIT)",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Sync operation failed",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerErrorResponse"
                        }
                    }
                }
            }
        },
        "/health": {
            "get": {
                "description": "Simple health check endpoint that verifies server responsiveness and basic storage connectivity for load balancers and monitoring systems\n\n## Configuration Dependencies:\n- **No authentication required** - Always accessible regardless of ENABLE_AUTH setting\n- **No rate limiting applied** - Excluded from THROTTLE_LIMIT restrictions\n- **Storage type independent** - Works with any storage backend\n\n## Health Verification:\n- Verifies server process is responding to HTTP requests\n- Tests basic storage connectivity by performing a count operation\n- Returns server uptime since startup for monitoring purposes\n- Always returns HTTP 200 if server can respond (fail-safe design)\n\n## Response Data:\n- status: Always \"healthy\" (indicates server responsiveness)\n- timestamp: Current server time in RFC3339 format\n- uptime: Duration since server startup\n- metrics.content_count: Total content items (verifies storage connectivity)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health \u0026 Monitoring"
                ],
                "summary": "Basic health check with storage connectivity verification",
                "responses": {
                    "200": {
                        "description": "Server is healthy and storage is accessible",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerHealthResponse"
                        }
                    }
                }
            }
        },
        "/health/detailed": {
            "get": {
                "description": "Comprehensive health check with detailed system metrics, storage diagnostics, and adaptive HTTP status codes\n\n## Configuration Dependencies:\n- **No authentication required** - Always accessible regardless of ENABLE_AUTH setting\n- **No rate limiting applied** - Excluded from THROTTLE_LIMIT restrictions\n- **Storage type dependent** - Returns different metrics based on storage backend\n\n## BadgerDB-Specific Diagnostics:\n- Database health metrics (size, corruption detection, performance)\n- Backup system status (last backup time, backup count, backup health)\n- Garbage collection statistics (frequency, duration, effectiveness)\n- Write queue health (queue depth, processing rate, emergency status)\n- Access manager statistics (tracker count, cleanup frequency)\n\n## Adaptive HTTP Status Codes:\n- **200 OK**: All systems healthy and performing optimally\n- **206 Partial Content**: System degraded but functional (high queue depth, slow GC, etc.)\n- **503 Service Unavailable**: System unhealthy (database corruption, backup failures, etc.)\n\n## Fallback for Other Storage Types:\n- Returns basic metrics (content count, storage type) for non-BadgerDB backends\n- Always returns HTTP 200 for unknown storage types",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health \u0026 Monitoring"
                ],
                "summary": "Detailed health check with comprehensive system diagnostics",
                "responses": {
                    "200": {
                        "description": "System is healthy",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerDetailedHealthResponse"
                        }
                    },
                    "206": {
                        "description": "System is degraded",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerDetailedHealthResponse"
                        }
                    },
                    "503": {
                        "description": "System is unhealthy",
                        "schema": {
                            "$ref": "#/definitions/internal_handlers.SwaggerDetailedHealthResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "internal_handlers.SwaggerBackupRequest": {
            "description": "Request body for creating manual backups",
            "type": "object",
            "properties": {
                "backup_name": {
                    "description": "Optional backup name",
                    "type": "string",
                    "example": "manual-backup-2024"
                },
                "immediate": {
                    "description": "Whether to create backup immediately",
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "internal_handlers.SwaggerBackupResponse": {
            "description": "Response for backup creation with details",
            "type": "object",
            "properties": {
                "data": {
                    "type": "object",
                    "properties": {
                        "backup_path": {
                            "type": "string",
                            "example": "/path/to/backup"
                        },
                        "backup_size_bytes": {
                            "type": "integer",
                            "example": 1024000
                        },
                        "created_at": {
                            "type": "string",
                            "example": "2024-01-01T00:00:00Z"
                        },
                        "message": {
                            "type": "string",
                            "example": "Backup created successfully"
                        },
                        "success": {
                            "type": "boolean",
                            "example": true
                        }
                    }
                },
                "message": {
                    "type": "string",
                    "example": "Backup created successfully"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "internal_handlers.SwaggerCleanupResponse": {
            "description": "Response for access tracker cleanup operations",
            "type": "object",
            "properties": {
                "data": {
                    "description": "Cleanup operation data",
                    "type": "object",
                    "properties": {
                        "duration_ms": {
                            "description": "Duration of the cleanup operation in milliseconds",
                            "type": "integer",
                            "example": 25
                        },
                        "removed_trackers": {
                            "description": "Number of removed trackers",
                            "type": "integer",
                            "example": 15
                        }
                    }
                },
                "message": {
                    "description": "Response message",
                    "type": "string",
                    "example": "Access tracker cleanup completed successfully"
                },
                "success": {
                    "description": "Operation success status",
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "internal_handlers.SwaggerContent": {
            "description": "Stored content with metadata and access tracking",
            "type": "object",
            "properties": {
                "access_count": {
                    "description": "Current access count",
                    "type": "integer",
                    "example": 3
                },
                "access_limit": {
                    "description": "Access limit",
                    "type": "integer",
                    "example": 10
                },
                "created_at": {
                    "description": "Creation timestamp",
                    "type": "string",
                    "example": "2024-01-01T00:00:00Z"
                },
                "data": {
                    "description": "Content data",
                    "type": "string",
                    "example": "Hello, World!"
                },
                "expires_at": {
                    "description": "Expiration timestamp",
                    "type": "string",
                    "example": "2024-12-31T23:59:59Z"
                },
                "id": {
                    "description": "Content ID",
                    "type": "string",
                    "example": "user-123-document"
                },
                "tag": {
                    "description": "Content tag",
                    "type": "string",
                    "example": "user-documents"
                },
                "type": {
                    "description": "Content type",
                    "type": "string",
                    "example": "text/plain"
                }
            }
        },
        "internal_handlers.SwaggerContentListResponse": {
            "description": "Response for content listing with pagination and filtering",
            "type": "object",
            "properties": {
                "data": {
                    "type": "object",
                    "properties": {
                        "contents": {
                            "description": "Array of content items",
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/internal_handlers.SwaggerContent"
                            }
                        },
                        "filters": {
                            "description": "Applied filters",
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            },
                            "example": {
                                "\"include_expired\"": "\"false\"}",
                                "{\"type\"": "\"text/plain\""
                            }
                        },
                        "limit": {
                            "description": "Number of items per page (limited by configuration, max: 1000)",
                            "type": "integer",
                            "example": 50
                        },
                        "offset": {
                            "description": "Number of items skipped",
                            "type": "integer",
                            "example": 0
                        },
                        "total": {
                            "description": "Total number of items matching the filter",
                            "type": "integer",
                            "example": 150
                        }
                    }
                },
                "message": {
                    "type": "string",
                    "example": "Content listed successfully"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "internal_handlers.SwaggerContentStatusResponse": {
            "description": "Content storage status response",
            "type": "object",
            "properties": {
                "data": {
                    "description": "Status data",
                    "type": "object",
                    "properties": {
                        "id": {
                            "description": "Content ID",
                            "type": "string",
                            "example": "user-123-document"
                        },
                        "status": {
                            "description": "Storage status: queued, stored, or not_found",
                            "type": "string",
                            "example": "stored"
                        }
                    }
                },
                "message": {
                    "description": "Response message",
                    "type": "string",
                    "example": "Content status retrieved successfully"
                },
                "success": {
                    "description": "Operation success status",
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "internal_handlers.SwaggerCountResponse": {
            "description": "Response for content count endpoint",
            "type": "object",
            "properties": {
                "data": {
                    "type": "object",
                    "properties": {
                        "count": {
                            "type": "integer",
                            "example": 42
                        }
                    }
                },
                "message": {
                    "type": "string",
                    "example": "Content count retrieved successfully"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "internal_handlers.SwaggerDetailedHealthResponse": {
            "description": "Detailed health check with comprehensive system metrics",
            "type": "object",
            "properties": {
                "metrics": {
                    "description": "Comprehensive metrics",
                    "type": "object",
                    "properties": {
                        "backup_status": {
                            "type": "string",
                            "example": "healthy"
                        },
                        "content_count": {
                            "type": "integer",
                            "example": 42
                        },
                        "database_status": {
                            "type": "string",
                            "example": "healthy"
                        },
                        "disk_usage": {
                            "type": "integer",
                            "example": 5120000
                        },
                        "gc_status": {
                            "type": "string",
                            "example": "healthy"
                        },
                        "last_backup": {
                            "type": "string",
                            "example": "2024-01-01T00:00:00Z"
                        },
                        "memory_usage": {
                            "type": "integer",
                            "example": 1024000
                        }
                    }
                },
                "status": {
                    "description": "System status",
                    "type": "string",
                    "example": "healthy"
                },
                "timestamp": {
                    "description": "Response timestamp",
                    "type": "string",
                    "example": "2024-01-01T00:00:00Z"
                },
                "uptime": {
                    "description": "Server uptime",
                    "type": "string",
                    "example": "1h30m45s"
                }
            }
        },
        "internal_handlers.SwaggerErrorResponse": {
            "description": "Standard error response format",
            "type": "object",
            "properties": {
                "data": {
                    "description": "Error details",
                    "type": "object",
                    "properties": {
                        "error": {
                            "type": "string",
                            "example": "Content size exceeds maximum allowed size"
                        }
                    }
                },
                "message": {
                    "description": "Error message",
                    "type": "string",
                    "example": "Validation failed"
                },
                "success": {
                    "description": "Success indicator (always false for errors)",
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "internal_handlers.SwaggerGCResponse": {
            "description": "Response for manual garbage collection operations",
            "type": "object",
            "properties": {
                "data": {
                    "description": "GC operation data",
                    "type": "object",
                    "properties": {
                        "duration": {
                            "description": "Duration of the GC operation",
                            "type": "string",
                            "example": "150ms"
                        }
                    }
                },
                "message": {
                    "description": "Response message",
                    "type": "string",
                    "example": "Garbage collection completed successfully"
                },
                "success": {
                    "description": "Operation success status",
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "internal_handlers.SwaggerHealthResponse": {
            "description": "Health check response with system status",
            "type": "object",
            "properties": {
                "metrics": {
                    "description": "Basic metrics",
                    "type": "object",
                    "properties": {
                        "content_count": {
                            "type": "integer",
                            "example": 42
                        }
                    }
                },
                "status": {
                    "description": "System status",
                    "type": "string",
                    "example": "healthy"
                },
                "timestamp": {
                    "description": "Response timestamp",
                    "type": "string",
                    "example": "2024-01-01T00:00:00Z"
                },
                "uptime": {
                    "description": "Server uptime",
                    "type": "string",
                    "example": "1h30m45s"
                }
            }
        },
        "internal_handlers.SwaggerMetricsResponse": {
            "description": "Comprehensive system metrics and statistics",
            "type": "object",
            "properties": {
                "backup_count": {
                    "type": "integer",
                    "example": 7
                },
                "backup_stats": {
                    "type": "object",
                    "properties": {
                        "last_backup_size": {
                            "type": "integer",
                            "example": 1024000
                        },
                        "total_backups": {
                            "type": "integer",
                            "example": 7
                        }
                    }
                },
                "content_count": {
                    "type": "integer",
                    "example": 42
                },
                "database_size_bytes": {
                    "type": "integer",
                    "example": 5120000
                },
                "gc_stats": {
                    "type": "object",
                    "properties": {
                        "avg_duration_ms": {
                            "type": "integer",
                            "example": 150
                        },
                        "last_run": {
                            "type": "string",
                            "example": "2024-01-01T00:00:00Z"
                        },
                        "runs_count": {
                            "type": "integer",
                            "example": 10
                        }
                    }
                },
                "health_status": {
                    "type": "string",
                    "example": "healthy"
                },
                "last_backup": {
                    "type": "string",
                    "example": "2024-01-01T00:00:00Z"
                },
                "queue_metrics": {
                    "type": "object",
                    "properties": {
                        "queue_depth": {
                            "type": "integer",
                            "example": 5
                        },
                        "total_errors": {
                            "type": "integer",
                            "example": 0
                        },
                        "total_processed": {
                            "type": "integer",
                            "example": 1245
                        },
                        "total_queued": {
                            "type": "integer",
                            "example": 1250
                        }
                    }
                }
            }
        },
        "internal_handlers.SwaggerStorageRequest": {
            "description": "Request body for storing content with configuration-dependent validation",
            "type": "object",
            "required": [
                "id",
                "type"
            ],
            "properties": {
                "access_limit": {
                    "description": "Optional access limit - content becomes inaccessible after this many retrievals (max: 1,000,000)",
                    "type": "integer",
                    "example": 10
                },
                "data": {
                    "description": "Content data - any JSON type, size limited by MAX_CONTENT_SIZE configuration (default: 10MB)",
                    "type": "string",
                    "example": "Hello, World!"
                },
                "expires_at": {
                    "description": "Optional expiration time - content becomes inaccessible after this time",
                    "type": "string",
                    "example": "2024-12-31T23:59:59Z"
                },
                "id": {
                    "description": "Content ID - must be unique, alphanumeric with dots, hyphens, underscores (max 255 chars)",
                    "type": "string",
                    "example": "user-123-document"
                },
                "tag": {
                    "description": "Optional tag for categorization and filtering",
                    "type": "string",
                    "example": "user-documents"
                },
                "type": {
                    "description": "Content type - validated against ALLOWED_CONTENT_TYPES configuration (default: application/json,text/plain)",
                    "type": "string",
                    "example": "text/plain"
                }
            }
        },
        "internal_handlers.SwaggerSuccessResponse": {
            "description": "Standard success response format",
            "type": "object",
            "properties": {
                "data": {
                    "description": "Response data (varies by endpoint)",
                    "type": "object",
                    "additionalProperties": true
                },
                "message": {
                    "description": "Success message",
                    "type": "string",
                    "example": "Operation completed successfully"
                },
                "success": {
                    "description": "Success indicator",
                    "type": "boolean",
                    "example": true
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "description": "API key authentication. Required when ENABLE_AUTH=true. Can also be provided as 'api_key' query parameter.",
            "type": "apiKey",
            "name": "X-API-Key",
            "in": "header"
        },
        "ApiKeyQuery": {
            "description": "API key authentication via query parameter. Alternative to X-API-Key header.",
            "type": "apiKey",
            "name": "api_key",
            "in": "query"
        }
    }
}